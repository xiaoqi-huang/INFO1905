import static org.junit.Assert.*;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

import textbook.LinkedBinaryTree;
import textbook.Position;

public class AssignmentTest {

	private LinkedBinaryTree<String> buildTree(String expression) {
		LinkedBinaryTree<String> tree = new LinkedBinaryTree<String>();
		String[] tokens = expression.split(" ");
		if (tokens.length == 1) {
			tree.addRoot(tokens[0]);
		} else if (tokens.length == 2) {
			Position<String> root = tree.addRoot(tokens[0]);
			tree.addLeft(root, tokens[1]);
		} else if (tokens.length == 3) {
			Position<String> root = tree.addRoot(tokens[0]);
			tree.addLeft(root, tokens[1]);
			tree.addRight(root, tokens[2]);
		} else if (tokens.length == 7 ) {
			Position<String> p1 = tree.addRoot(tokens[0]);
			Position<String> p2 = tree.addLeft(p1, tokens[1]);
			Position<String> p3 = tree.addRight(p1, tokens[2]);
			tree.addLeft(p2, tokens[3]);
			tree.addRight(p2, tokens[4]);
			tree.addLeft(p3, tokens[5]);
			tree.addRight(p3, tokens[6]);
		}
		return tree;
	}

	// Set up JUnit to be able to check for expected exceptions
	@Rule
	public ExpectedException thrown = ExpectedException.none();

	// Some simple testing of prefix2tree
	@Test(timeout = 100)
	public void testPrefix2tree() {

		LinkedBinaryTree<String> tree;

		tree = Assignment.prefix2tree("hi");
		assertEquals(1, tree.size());
		assertEquals("hi", tree.root().getElement());

		tree = Assignment.prefix2tree("+ 5 10");
		assertEquals(3, tree.size());
		assertEquals("+", tree.root().getElement());
		assertEquals("5", tree.left(tree.root()).getElement());
		assertEquals("10", tree.right(tree.root()).getElement());

		tree = Assignment.prefix2tree("- 5 10");
		assertEquals(3, tree.size());
		assertEquals("-", tree.root().getElement());
		assertEquals("5", tree.left(tree.root()).getElement());
		assertEquals("10", tree.right(tree.root()).getElement());

		tree = Assignment.prefix2tree("* 5 10");
		assertEquals(3, tree.size());
		assertEquals("*", tree.root().getElement());
		assertEquals("5", tree.left(tree.root()).getElement());
		assertEquals("10", tree.right(tree.root()).getElement());

		tree = Assignment.prefix2tree("+ 5 - 4 3");
		assertEquals(5, tree.size());
		assertEquals("+", tree.root().getElement());
		assertEquals("5", tree.left(tree.root()).getElement());
		assertEquals("-", tree.right(tree.root()).getElement());
		assertEquals("4", tree.left(tree.right(tree.root())).getElement());
		assertEquals("3", tree.right(tree.right(tree.root())).getElement());

		thrown.expect(IllegalArgumentException.class);
		tree = Assignment.prefix2tree("+ 5 - 4");
	}

	// example of using the Assignment.equals method to check that "- x + 1 2" simplifies to "- x 3"
	@Test(timeout = 100)
	public void testSimplify1() {
		LinkedBinaryTree<String> tree = Assignment.prefix2tree("- x + 1 2");
		tree = Assignment.simplify(tree);
		LinkedBinaryTree<String> expected = Assignment.prefix2tree("- x 3");
		assertTrue(Assignment.equals(tree, expected));
	}

	/* *************************************************************************
	 * testSubstituteMap
	 * ************************************************************************* */
	 @Test(timeout = 100)
	 public void testSubstituteMap_Null() {
		 thrown.expect(IllegalArgumentException.class);
		 Assignment.substitute(null, new HashMap<String, Integer>());
		 thrown.expect(IllegalArgumentException.class);
		 Assignment.substitute(new LinkedBinaryTree<String>(), null);
		 thrown.expect(IllegalArgumentException.class);
		 Assignment.substitute(null, null);
	 }

	 @Test(timeout = 100)
	 public void testSubstituteMap_InvalidTree() {
		 LinkedBinaryTree<String> tree = buildTree("+ 1 - + val 1 val");

		 thrown.expect(IllegalArgumentException.class);
		 Assignment.substitute(tree, new HashMap<String, Integer>());
	 }

	 @Test(timeout = 100)
	 public void testSubstituteMap_SubstitueNull() {
		 LinkedBinaryTree<String> tree = Assignment.prefix2tree("* * a b * a b");
		 HashMap<String, Integer> map = new HashMap<String, Integer>();
		 map.put("a", 1);
		 map.put("b", null);
		 thrown.expect(IllegalArgumentException.class);
		 Assignment.substitute(tree, map);
	 }

	/* *************************************************************************
	 * testIsArithmeticExpression
	 * ************************************************************************* */
	 @Test(timeout = 100)
	 public void testIsArithmeticExpression_Null() {
		 assertFalse(Assignment.isArithmeticExpression(null));
	 }

	 @Test(timeout = 100)
	 public void testIsArithmeticExpression_OneOperator() {
		 LinkedBinaryTree<String> tree = buildTree("-");
		 assertFalse(Assignment.isArithmeticExpression(tree));
	 }

	 @Test(timeout = 100)
	 public void testIsArithmeticExpression_OneValue() {
		 LinkedBinaryTree<String> tree = buildTree("1");
		 assertTrue(Assignment.isArithmeticExpression(tree));
	 }

	 @Test(timeout = 100)
	 public void testIsArithmeticExpression_OneVariable() {
		 LinkedBinaryTree<String> tree = buildTree("val");
		 assertTrue(Assignment.isArithmeticExpression(tree));
	 }

	 @Test(timeout = 100)
	 public void testIsArithmeticExpression_Simple() {
		 LinkedBinaryTree<String> tree = buildTree("* 1");
		 assertFalse(Assignment.isArithmeticExpression(tree));
		 tree = buildTree("* val");
		 assertFalse(Assignment.isArithmeticExpression(tree));
		 tree = buildTree("1 *");
		 assertFalse(Assignment.isArithmeticExpression(tree));
		 tree = buildTree("1 val");
		 assertFalse(Assignment.isArithmeticExpression(tree));
		 tree = buildTree("val 1");
		 assertFalse(Assignment.isArithmeticExpression(tree));
		 tree = buildTree("val *");
		 assertFalse(Assignment.isArithmeticExpression(tree));

		 tree = buildTree("* * 1");
		 assertFalse(Assignment.isArithmeticExpression(tree));
		 tree = buildTree("* * val");
		 assertFalse(Assignment.isArithmeticExpression(tree));
		 tree = buildTree("* 1 val");
		 assertTrue(Assignment.isArithmeticExpression(tree));
		 tree = buildTree("1 * 1");
		 assertFalse(Assignment.isArithmeticExpression(tree));
		 tree = buildTree("1 * val");
		 assertFalse(Assignment.isArithmeticExpression(tree));
		 tree = buildTree("1 1 val");
		 assertFalse(Assignment.isArithmeticExpression(tree));
		 tree = buildTree("val * 1");
		 assertFalse(Assignment.isArithmeticExpression(tree));
		 tree = buildTree("val * val");
		 assertFalse(Assignment.isArithmeticExpression(tree));
		 tree = buildTree("val 1 val");
		 assertFalse(Assignment.isArithmeticExpression(tree));
	 }

	 @Test(timeout = 100)
	 public void testIsArithmeticExpression_ComplexValid() {
		 LinkedBinaryTree<String> tree = buildTree("* + - 1 val val 1");
		 assertTrue(Assignment.isArithmeticExpression(tree));
	 }

	 @Test(timeout = 100)
	 public void testIsArithmeticExpression_ComplexInvalid() {
		 LinkedBinaryTree<String> tree = buildTree("+ 1 - + val 1 val");
		 assertFalse(Assignment.isArithmeticExpression(tree));
	 }
}
